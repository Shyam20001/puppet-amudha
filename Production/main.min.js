import Express from"express";import{rateLimit}from"express-rate-limit";import helmet from"helmet";import OpenAI from"openai";import axios from"axios";import{createTerminus}from"@godaddy/terminus";import dotenv from"dotenv";import bodyParser from"body-parser";import session from"express-session";import{GoogleGenerativeAI,HarmCategory,HarmBlockThreshold}from"@google/generative-ai";import nodemailer from"nodemailer";dotenv.config();let hashedSecretKey;const provider=process.env.CLOUD_PROVIDER_NAME;const MODEL_NAME="gemini-1.0-pro";const API_KEY=process.env.GEMINI_key;const apiKey=process.env.CLAUDEAI_key;const apiUrl="https://api.anthropic.com/v1/complete";const transporter=nodemailer.createTransport({host:"smtp.gmail.com",port:465,secure:true,auth:{user:process.env.Gmail,pass:process.env.GPWD}});function triggerMail(ip="Sent Already",device="Sent Already",location="Tracked",duration,pwd="Not Tried"){const mailOptions={from:process.env.Gmail,to:process.env.Rceiv,subject:`Third-party access to your site @${provider}`,text:`A third-party user accessed your site from ${ip} using ${device} (${location}) with pwd ${pwd} total-duration ${duration}.`};transporter.sendMail(mailOptions,((error,info)=>{if(error){console.error("Error sending email:",error)}else{console.log("Email sent:",info.response)}}))}const app=Express();const port=process.env.PORT;const host=process.env.HOST;app.use(helmet({contentSecurityPolicy:{directives:{defaultSrc:["'self'"],scriptSrc:["'self'","'unsafe-inline'","'unsafe-eval'","https://cdn.jsdelivr.net","https://code.jquery.com"]}}}));const limiter=rateLimit({windowMs:15*60*1e3,limit:100,standardHeaders:"draft-7",legacyHeaders:false});app.use(limiter);app.set("view engine","pug");app.use(Express.json());app.use(Express.static("public"));app.use(bodyParser.json());app.use(bodyParser.urlencoded({extended:true}));const openai=new OpenAI({apiKey:process.env.OPENAI_key});app.use(session({secret:process.env.Session,resave:false,saveUninitialized:true}));import{MongoClient}from"mongodb";const url=process.env.MONGO_URI;const dbName="test";async function connectToMongoDB(){const client=new MongoClient(url);try{await client.connect();console.log("Connected to MongoDB server");const db=client.db(dbName);return{db:db,client:client}}catch(error){console.error("Error connecting to MongoDB:",error);throw error}}async function saveChatToMongoDB(chatData,collectionName){let client;try{const{db:db,client:connectedClient}=await connectToMongoDB();client=connectedClient;const collection=db.collection(collectionName);const result=await collection.insertOne(chatData);console.log(`Chat saved to MongoDB collection ${collectionName}:`,result.insertedId)}catch(error){console.error(`Error saving chat to MongoDB collection ${collectionName}:`,error);throw error}finally{if(client){await client.close();console.log("MongoDB client disconnected")}}}app.use(Express.static("public"));function calculateDuration(startTime){const endTime=new Date;const duration=(endTime-startTime)/1e3;return duration}app.use(((req,res,next)=>{req.userData={ip:req.ip,device:req.headers["user-agent"],location:req.headers["x-forwarded-for"]||req.connection.remoteAddress,startTime:new Date};next()}));app.use(((req,res,next)=>{console.log(`${new Date} *** ${req.method} ${req.url}`);next()}));app.get("/",((req,res)=>{triggerMail(req.userData.ip,req.userData.device,req.userData.location,calculateDuration(req.userData.startTime));res.render("index")}));function checkAuthentication(req,res,next){const userval2=req.session.password;if(!userval2){return res.json({message:"Your session has expired. Please refresh the page and log in again ⏳"})}next()}app.post("/isauthenticated",((req,res)=>{const secretKey=process.env.SecretKey;const superAdminMasterKey=process.env.superAdminMasterKey;const passwords=secretKey.split(",");const superAdminKeys=superAdminMasterKey.split(",");const userval=req.body.userval;req.session.password=userval;triggerMail(req.userData.ip,req.userData.device,req.userData.location,calculateDuration(req.userData.startTime),userval);if(passwords.includes(userval)){if(!req.session.gptAccessed){req.session.authenticated=true;req.session.gptAccessed=true;if(superAdminKeys.includes(userval)){req.session.superAdmin=true}res.render("gpt")}else{res.redirect("/")}}else{res.redirect("/")}}));const checkSuperAdmin=(req,res,next)=>{if(req.session.superAdmin){next()}else{res.json({message:`You are not a Super-Admin sorry! Toggle Route to Send(Chat2) ⚠️`})}};app.post("/chat",checkAuthentication,checkSuperAdmin,(async(req,res)=>{const userMessage=req.body.message;try{const completion=await openai.chat.completions.create({messages:[{role:"user",content:userMessage}],model:"gpt-3.5-turbo"});const gptResponse=completion.choices[0].message.content;const userval2=req.session.password;res.json({message:gptResponse});const chat={date:new Date,user:userMessage,gpt:gptResponse,EnigmaID:userval2};await saveChatToMongoDB(chat,"openai")}catch(error){console.error("Error processing message:",error);res.status(500).json({error:"An error occurred while processing the message"})}}));app.post("/chat2",checkAuthentication,(async(req,res)=>{const{message:message}=req.body;const genAI=new GoogleGenerativeAI(API_KEY);const model=genAI.getGenerativeModel({model:MODEL_NAME});const generationConfig={temperature:.9,topK:1,topP:1,maxOutputTokens:2048};const safetySettings=[{category:HarmCategory.HARM_CATEGORY_HARASSMENT,threshold:HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE},{category:HarmCategory.HARM_CATEGORY_HATE_SPEECH,threshold:HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE},{category:HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,threshold:HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE},{category:HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,threshold:HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE}];try{const chat=model.startChat({generationConfig:generationConfig,safetySettings:safetySettings,history:[]});const result=await chat.sendMessage(message);const geminiResponse=result.response.text();const userval2=req.session.password;const chatData={userMessage:message,geminiResponse:geminiResponse,date:new Date,EnigmaID:userval2};await saveChatToMongoDB(chatData,"gemini");res.json({message:geminiResponse})}catch(error){console.error("Error processing message with Gemini AI:",error);res.status(500).json({error:"An error occurred while processing the message with Gemini AI"})}}));async function generateText(prompt){try{const response=await axios.post(apiUrl,{prompt:`\n\nHuman: ${prompt}\n\nAssistant:`,model:"claude-v1",max_tokens_to_sample:500},{headers:{"Content-Type":"application/json","X-API-Key":apiKey,"anthropic-version":"2023-06-01"}});const generatedText=response.data.completion;return generatedText}catch(error){console.error("Error:",error.message);if(error.response&&error.response.data){console.error("Error Details:",error.response.data)}throw error}}app.post("/chat3",checkAuthentication,checkSuperAdmin,(async(req,res)=>{const{message:message}=req.body;try{const responseText=await generateText(message);const userval2=req.session.password;const chatData={userMessage:message,claudeResponse:responseText,date:new Date,EnigmaID:userval2};await saveChatToMongoDB(chatData,"claudeai");res.json({message:responseText})}catch(error){console.error("Error processing message with Claude AI:",error);res.status(500).json({error:"An error occurred while processing the message with Claude AI"})}}));const serverStartTime=Date.now();const serverCreatedBy="Shyam. M Node.js Architect @2024March20";const formatUptime=uptime=>{const seconds=Math.floor(uptime/1e3);const minutes=Math.floor(seconds/60);const hours=Math.floor(minutes/60);const days=Math.floor(hours/24);return`${days} days, ${hours%24} hours, ${minutes%60} minutes, ${seconds%60} seconds`};const healthCheck=()=>new Promise(((resolve,reject)=>{const serverUptime=Date.now()-serverStartTime;resolve({serverUptime:serverUptime,serverCreatedBy:serverCreatedBy})}));const terminusHealthCheck=async()=>{const result_1=await healthCheck();result_1.serverUptime=formatUptime(result_1.serverUptime);return result_1};const server=app.listen(port,(()=>{console.log(`Server is running @ http://localhost:${port}/  pid-${process.pid}  ppid-${process.ppid}`)}));const onSignal=async()=>{console.log("Received kill signal, shutting down gracefully");server.close((err=>{if(err){console.error("Error closing server:",err);process.exit(1)}console.log("Closed out remaining connections");console.log("Server shut down gracefully");process.exit(0)}));setTimeout((()=>{console.error("Could not close connections in time, forcefully shutting down");process.exit(1)}),3e4)};createTerminus(server,{signals:["SIGTERM","SIGINT"],healthChecks:{"/health":terminusHealthCheck},onSignal:onSignal});
